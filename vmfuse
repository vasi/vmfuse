#!/usr/bin/ruby
require 'pathname'
require 'fileutils'
require 'open3'

class VM
	SSHPort = 22
	SSHUserHost = 'root@localhost'
		
	BaseVM = 'vmfuse'
	BaseSnapshot = 'vmfuse'
	Group = '/vmfuse'
	SSHPF = 'vmfuse'
	VMMountPoint = 'mnt'
	
	def create_name(base)
		# TODO: Check if it exists already?
		base + '-' + rand(36**10).to_s(36)
	end
	def choose_port
		# TODO: Check if port is in use?
		1025 + rand(60000)
	end
	
	attr_reader :name, :port
	def initialize
		@name = create_name(BaseVM)
		@port = choose_port
		
		manage('clonevm', BaseVM, '--snapshot', BaseSnapshot,
			'--groups', Group, '--name', @name, '--options', 'link', '--register')
		manage('modifyvm', @name, '--natpf1',
			SSHPF + ',tcp,,' + @port.to_s + ',,' + SSHPort.to_s)
	end
	
	def basedir
		info = manage('showvminfo', @name)
		config = info[/^Config file:\s*(.*)$/, 1] \
			or raise "Can't determine VM directory"
		File.dirname(config)
	end
	
	def add_part(disk, part)
		@part = part
		vmdk = File.join(basedir, 'part.vmdk')
		puts vmdk
		
		system('sudo', 'VBoxManage', 'internalcommands', 'createrawvmdk',
			'-filename', vmdk, '-rawdisk', disk, '-partitions', part.to_s)
		system('sudo', 'chown', '-R', Process.uid.to_s, basedir.to_s)
		system('sudo', 'chown', Process.uid.to_s, disk + 's' + part.to_s)
		
		manage('storageattach', @name, '--storagectl', 'SATA', '--port', '1',
			'--type', 'hdd', '--medium', vmdk)
	end
	
	def cmd(cmd, env: {})
		out, err, status = Open3.capture3(env, *cmd)
		unless status.success?
			$stderr.print err
			raise 'Error executing %s' % args.join(' ')
		end
		return out
	end
	def manage(*args)
		# TODO: Use VBOX_USER_HOME
		cmd(['VBoxManage', *args])
	end
	def ssh_opts
		# Don't prompt user to check host identity
		['-o', 'NoHostAuthenticationForLocalhost=yes', '-p', @port.to_s]
	end
	def ssh(*args)
		cmd(['ssh', *ssh_opts, SSHUserHost, *args])
	end
	def sshfs(mountpoint)
		# -f: Foreground
		remote = SSHUserHost + ':' + VMMountPoint
		cmd(['sshfs', *ssh_opts, '-f', remote, mountpoint])
	end
	
	def mount(mountpoint, dev = nil)
		dev ||= '/dev/sdb' + @part.to_s
		manage('startvm', @name, '--type', 'headless')
		ssh('mount', dev, VMMountPoint)
		
		mount_wait(mountpoint) { cleanup }
	end

	def mount_wait(mountpoint, &cleanup_block)
		dev = File.stat(mountpoint).dev

		r, w = IO.pipe
		
		# This process runs sshfs, and then alerts our daemon on exit
		fork do
			r.close
			sshfs(mountpoint)
			w.close # alert daemon
		end
		
		w.close
		# Wait for mount to complete
		loop { dev == File.stat(mountpoint).dev or break }
		
		Process.daemon
		r.read
		r.close
		cleanup_block[]
	end	
	
	def cleanup
		ssh('umount', VMMountPoint)
		ssh('poweroff')
		
		begin
			manage('unregistervm', @name, '--delete')
		rescue
			sleep 1
			retry
		end
		FileUtils.rm_r(basedir) if File.exist?(basedir)
	end
end

vm = VM.new
vm.add_part('/dev/disk0', 8)
vm.mount('mnt', '/dev/fedora_hastings/root')
