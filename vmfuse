#!/usr/bin/ruby
require 'pathname'
require 'fileutils'
require 'open3'
require 'socket'
require 'timeout'

class VM
	VMHost = 'localhost'
	
	SSHPort = 22
	SSHUserHost = 'root@' + VMHost
		
	BaseVM = 'vmfuse'
	BaseSnapshot = 'vmfuse'
	Group = '/vmfuse'
	SSHPF = 'vmfuse'
	VMMountPoint = 'mnt'
	
	# Choose a name for the temporary VM
	def choose_name(base)
		suffix_length = 10
		suffix_base = 36
		
		loop do
			name = base + '-' + rand(suffix_base ** suffix_length).to_s(suffix_base)
			# Short race condition between name choice and creation
			return name unless all_vms.include? name
		end
	end
	
	# Choose an unused port to access the VM via SSH
	def choose_port
		port_range = 1024..65535
		connect_timeout = 1
		
		loop do
			begin
				port = rand(port_range)
				Timeout::timeout(connect_timeout) { TCPSocket.new(VMHost, port) }
				# It's in use, loop again
			rescue Timeout::Error, Errno::ECONNREFUSED, Errno::EHOSTUNREACH
				return port # We found an unused port!
			end
		end
	end
	
	attr_reader :name, :port
	def initialize
		@name = choose_name(BaseVM)
		@port = choose_port
		
		manage('clonevm', BaseVM, '--snapshot', BaseSnapshot,
			'--groups', Group, '--name', @name, '--options', 'link', '--register')
		manage('modifyvm', @name, '--natpf1',
			SSHPF + ',tcp,,' + @port.to_s + ',,' + SSHPort.to_s)
	end
	
	# Find the directory where the VM's files are stored.
	# Usually something like "~/VirtualBox VMs".
	def basedir
		info = manage('showvminfo', '--machinereadable', @name)
		config = info[/^CfgFile=\"(.*)\"$/, 1] \
			or raise "Can't determine VM directory"
		File.dirname(config)
	end
	
	# Get names all existing VMs
	def all_vms
		manage('list', 'vms').scan(/^"(.*)" \{[-\h]+\}/)
	end
	
	def add_part(disk, part)
		@part = part
		vmdk = File.join(basedir, 'part.vmdk')
		
		system('sudo', 'VBoxManage', 'internalcommands', 'createrawvmdk',
			'-filename', vmdk, '-rawdisk', disk, '-partitions', part.to_s)
		system('sudo', 'chown', '-R', Process.uid.to_s, basedir.to_s)
		system('sudo', 'chown', Process.uid.to_s, disk + 's' + part.to_s)
		
		manage('storageattach', @name, '--storagectl', 'SATA', '--port', '1',
			'--type', 'hdd', '--medium', vmdk)
	end
	
	# Run a command, optionally modifying the environment.
	# Returns stdout. Suppresses stderr except in case of error.
	def cmd(cmd, env: {})
		out, err, status = Open3.capture3(env, *cmd)
		unless status.success?
			$stderr.print err
			raise 'Error executing %s' % cmd.join(' ')
		end
		return out
	end
	
	# Manage the VM with VBoxManage.
	def manage(*args)
		# TODO: Use VBOX_USER_HOME
		cmd(['VBoxManage', *args])
	end
	
	# Common options for SSH-related commands.
	def ssh_opts
		# Don't prompt user to check host identity
		['-o', 'NoHostAuthenticationForLocalhost=yes', '-p', @port.to_s]
	end
	
	# Run a command on the VM via SSH.
	def ssh(*args)
		cmd(['ssh', *ssh_opts, SSHUserHost, *args])
	end
	
	# Mount the VM's vended directory onto `mountpoint`.
	# Returns only on error, or when unmounted.
	def sshfs(mountpoint)
		# -f: Foreground
		remote = SSHUserHost + ':' + VMMountPoint
		cmd(['sshfs', *ssh_opts, '-f', remote, mountpoint])
	end
	
	def mount(mountpoint, dev = nil)
		dev ||= '/dev/sdb' + @part.to_s
		manage('startvm', @name, '--type', 'headless')
		ssh('mount', dev, VMMountPoint)
		
		mount_wait(mountpoint) { cleanup }
	end

	def mount_wait(mountpoint, &cleanup_block)
		dev = File.stat(mountpoint).dev

		r, w = IO.pipe
		
		# This process runs sshfs, and then alerts our daemon on exit
		fork do
			r.close
			sshfs(mountpoint)
			w.close # alert daemon
		end
		
		w.close
		# Wait for mount to complete
		loop { dev == File.stat(mountpoint).dev or break }
		
		Process.daemon
		r.read
		r.close
		cleanup_block[]
	end	
	
	def cleanup
		ssh('umount', VMMountPoint)
		ssh('poweroff')
		
		begin
			manage('unregistervm', @name, '--delete')
		rescue
			sleep 1
			retry
		end
		FileUtils.rm_r(basedir) if File.exist?(basedir)
	end
end

vm = VM.new
vm.add_part('/dev/disk0', 8)
vm.mount('mnt', '/dev/fedora_hastings/root')
